Python tutor 


object oriented programming
1.class
2.object
3.method
4.inheritance
5.polymorphism
6.data abstraction
7.encapculation



class 
*class is a code templete for creating objects.
*The class can be defined as a collection of objects 
*It is a logical entity that has some specific attribute and methods.
*In python a class is created by the keyword class.

 object
*The object is an entity that has state and behaviour.

class person:
def_init_(self, name, age):
self.name = name
self.age = age
p1= person("john",36)

print(p1.name)                                                                                                                                                         
print(p1.age)
p1.hello()

*The _init_() function is called automation being used to create a new object.

class person
def_init_(self, name, age):
self.name = name
self.age = age
p1=person("john",36)

print(p1)

set parameters 
*It does not have to be named self, you can call it whatever you like. 
*but it has to be the first parameter of any function in the class.

constructor
example 

class Imagecon:
    def __init__(self):
        self.image ="IMAGE INDIA"
    def print_image(self):
        print(self.image)
obj = Imagecon()
obj.print_image()


output:
IMAGE INDIA

destructor
Destructor is called when an object gerts destroyed.

Destructor
example

class Employee:
    def __init__(self):
        print("Employee created")
    def __del__(self):
        print("Destructor called, Employee deleted")
obj=Employee()
del obj

output
Employee created
Destructor called, Employee deleted



class School:
    def __init__(self):
        print("Init constructor")
    def __del__(self):
        print("delete constructor")
    def hello(self):
        print("Hello function")

print('calling class')
p = School()
p.hello()
print("class end")    

output
calling class
Init constructor
Hello function
class end        

class Animal:
    def speak(self):
        print("Animal speaking")

class Dog(Animal):
    def bark(self):
        print("dog braking")

d=Dog()
d.bark()
d.speak()
 
output:
dog braking
Animal speaking

INHERITANCE:

class Animal:
    def speak(self):
        print("Animal speaking")

class Dog(Animal):
    def bark(self):
        print("dog braking")

class Dogchild(Dog):
    def eat(self):
        print("Eating bread...")
d=Dogchild()
d.bark()
d.speak()
d.eat()


output
dog braking
Animal speaking
Eating bread...

Encapculation-example

class demo:
    a=10
    b=20
    print(b)
    def func(self):
        print("The value of a is ",demo.a)
    def func2(self):
        print("The value of b is",demo.b)

c=demo()
print(c.b)
c.func2()

output:
20
20
The value of b is 20


class Shape:
    def __init__(self, length, breadth):
        self._length = length
        self._breadth = breadth

    def displaySides(self):
        print("length:",self._length)
        print("Breadth:",self._breadth)

class Rectangle(Shape):
    def __init__(self, length, breadth):
        Shape.__init__(self, length, breadth)


    def calculateArea(self):
        print("Area:", self._length*self._breadth)


obj = Rectangle(80,50)
obj.displaySides()
obj.calculateArea()

output
length: 80
Breadth: 50
Area: 4000

class parents():
    def show(self):
        print("Inside parents")
class child(parents):
    def show(self):
        parents.show(self)
        print("Inside child")

obj=child()
obj.show()



output
Inside parents
Inside child





class cal :
    def add(self,a=None,b=None,c=None):
        if a!=None and b!=None and c!=None:
            return a+b+c
        elif a!=None and b!=None:
            return a-b
        elif a!=None:
            return a

d=cal()
print(d.add(1,2))
print(d.add(5,6,7))
print(d.add(6))


output

-1
18
6


from abc import ABC, abstractmethod
class Car(ABC):
    def mileage(self):
        pass
class Tesla(Car):
    def mileage(self):
        print("The mileage is 30kmph")
class Renault(Car):
    def mileage(self):
        print("The mileage is 27kmph")

t=Tesla()
t.mileage()
r=Renault()
r.mileage()
x=Car()
x.mileage()


output
The mileage is 30kmph
The mileage is 27kmph

Problems

list=[44,23,789,56,11,8,4004,324]
largest=list[0]
second_largest=list[0]
for num in list:
    if num>largest:
        second_largest=largest
        largest=num
    elif num>second_largest and num!=largest:
        second_largest=num
print("The 1st largest number is",largest)
print("The 2nd largest number is",second_largest)


output
The 1st largest number is 4004
The 2nd largest number is 789


3.program to reverse a string. input="hello" output="olleh"
input_string="hello"
reversed_string=""
for i in range(len(input_string) -1, -1, -1):
    reversed_string+=input_string[i]
print("reversed string :",reversed_string)    


output:
reversed string : olleh

4.find the factorial of a number.5  5*4*3*2*1
5.Fibonacci sequences upto n terms. 0,1,1,2,3,5,8,15,21
6.Check if two strings is a palindrome. abcdcba
7.Check if two strings are anagrams. abc==bca
14.Display a python program class for a sin
15.Create a class Library that allow user to:
Attributes:
books:A list to store the names of available books in the library.
Methods:
display_books():Display the list of available books.
lend_book(book_name):Lends a book to a user(removes the book from the available list).
add_book(book_name):Adds a book back to the library (adds the book to the available list).




class Bank:
    def __init__(Self):
        Self.acc_num = 12345
        Self.balance = 0
    def deposit(Self,amount):
        Self.balance += amount
    def withdraw(Self,amount):
        if(amount>Self.balance):
            print("insufficient balance")
        else:
            Self.balance -= amount
    def display_balance(Self):
        print("acount balance is = ",Self.balance)
user1 = Bank()
user1.deposit(1000)
user1.display_balance()
user1.withdraw(2000)
user1.withdraw(500)
user1.display_balance()

output:
account balance is =  1000
insufficient balance
acount balance is =  500
     
            


n= int(input("Enter a num:"))
for row in range(1,n+1):
    for col in range(n+1,row,-1):
        print(row,end=" ")
    print()
    
output:
Enter a num:7
1 1 1 1 1 1 1 
2 2 2 2 2 2 
3 3 3 3 3 
4 4 4 4 
5 5 5 
6 6 
7  


x= int(input("Enter a number:"))
n1,n2=0,1
print(n1," ",n2,end=" ")

for x in range(2,x):
    temp=n1+n2
    print(temp, end=" ")
    n1=n2
    n2=temp
    
output:
Enter a number:10
0   1 1 2 3 5 8 13 21 34 
s    


Given a binary arraay nums, return the maximum number of consecutive 1's in the array.
Example1: 
Input:nums=[1,2,0,1,1,1]
output:3
Explanation:The first two digits or the last three digits are consecutive 1's. The maximum number of consecutive 1s is 3.

Example2:
Input:nums=[[1,0,1,1,0,1]
output:2

*import script1

added_num = script1.sum(4,2)
print(added_num)



DSA:
*Linear Data Structure: A Data structure in which data elements are arranged sequentially or linearly, where each elements is attached to its previous and next adjacent elements, is called linear data structure>
Example: array, stack, queue, etc>4
*Nomn-Linear structure:Data structure where data element are not placed

CLASSIFICATION OF DATA STRUCTURE:
*Data sturcture: 
.Lineafr data structure 
.Non-Linear Data structure
-Linear Dta structure:
1.String Data structure: Example- Array
2.Dynamic Data Structure: Example- Queue, stack

.Computer graphics
.Operating systems
.Databases
.Artificial intelligence

Applications of Data Structure:

.Efficiency: Data structure allow for efficient stroage and retrieval of data, which is important in applications where performance is critical.
.Flexibility:Data structure provide a flexible way to organize and store data, allowing for easy modification and manipukation.
.Reusability:Data structure can be used in multiple programs and applications, reducing the need for redundant code.
.Maintainability:Well-designed data structure can make programs easier to understand , modify and maintain over time.

Algoritms
A set of instructions that are follower in a specific order to complete a task or slove a program.
Algorithms are used in many areas , including computer programming.

WHAT IS ALGORITHM?
input...........................>set of rules to obtain the expected output from the given input...................................>output
                                                                 (algorithm)

Algorithm to add 3 numbers and print their sum:

Start
Declare 3 integers variable num1, num2, and num3.
Take the three numbers to be added as input in variables num1, num2, and num3 respectively.
declare an integer variable sum to be store the resultant sum of the 3 numbers.
add the 3 numbers and store the result in the variable sum.
print the value of the variable sum.
End

Write  a algorithm to check the age is adult or not?

def check_adult(age):
    if age >=18:
        return "Adult"
    else:
        return "Not an adult"h
age=int(input("Enter your age: "))
result = check_adult(age)
print(result)

output:
.Enter your age: 20
Adult

.Enter your age: 16
Not an adult

Sorting Algorithms:Bubble Sort, insertion sort, and many more. These algorithm are used to sort the data in a particular format.
Searching algorithms: Linear search, binary search, etc. These algorithm are used in findimg a value or record that the user demand.
Graph Algorithm: It is used to find solutions to problems like finding the shortest path between cities, and real-life problems like traveling salesman problems.

An algorithm is defined as complex based on the amount of space and Time it consumes.
Hence the complexity of an algorithm refers to the measures of the time that it will need to store all the data (input, tempory data , and output)

Time complexity: Time is measured by counting the number of key operations such as comparison in the sorting algorithm.
Space Complexity: Space is measured by counting the maximum memory space required by the algorithm to run/execute.

The space complexity of an algorithm refers to the amount of memeory required by the algorithm to store the variables and get the result .
This can be for inputs, temporary operations, or output.

Fixed Part: This rrefers to the space that is required by the algorithm. For example, input variables, output variables, program size, etc.
Variable Part : This refers to the space that can be different based on the implementation of the algorithm. For Example, temporary variables, dynamic memory allocations, recursion

Time complexity:
The time complexity of an algorithm refers to the amount of time required by the algorithm to execute and get the result.
This can be for normal opreations, conditional if-else, loop statements, etc.

Constant time part:
Any instruction that is executed just once come in this part.
For example, input, output, if-else, switch, airthmatic operations, etc.
Variable time part:
Any instruction that is executed more than once , say n times, comes in this part.
For example, loops, recursion, etc.

They are two commonly studied cases of complexity in algorithm:
1.Best case complexity: The best- case scenerio for an algorithm is the scenerio in which the algorithm performs the minimum amount of work(e.g. takes the shortest amount of time, uses the least amount of memort,etc)
2.Worst case complexity: The worst- case scenerio for an algorithm is the scenerio in which the algorithm performs the maximum amount of work(e.g. takes the longest amount of time, uses the most amount of memory,etc.) 

O(1)
     print("Hello world")
O(n)
  n=8
  for i in range(1, n+1):
     print("Hello world!!!")
O(log(n))
  n=8
  for i in range(1, n+1, 2):
      print ("Hello world!!")

*Basic Billing System: Scenario: You're building a basic billing system for a grocery store. Implement a system that can take the name of an item, its price, and quantity, then calculate the total cost including a 5% tax. Example :Input:"Apple",3,5,.....>  output: Total= 15.75 .

def billing_system(item_name, price_per_item, quantity):
    total_cost = price_per_item *quantity
    total_with_tax=total_cost + (total_cost*0.05)
    return item_name, total_with_tax
print(billing_system("Apple",3,5))
print(billing_system("Banana",2,15))
print(billing_system("Mango",4,5))

Output:
('Apple', 15.75)
('Banana', 31.5)
('Mango', 21.0)


*Flight Booking System:Scenario: A flight booking system has seats of three types (Economy, Business, First-class).Write a program to: Take inputs for seat preferences and availabilty. Calculate the total cost based on the seat type chosen (Economy:$100, Business:$200 First-class:$300). Output the  bbooking summary.
 Example: Input:"Economy",2.....> Output: Total cost = $200

*Restaurant Billing System:Scenario:Implement a restaurant billing system. The program should: Take multiple ordders. Calculate the total cost including tax(8%). Offer discounts based on order value (e.g., 10% discounts for orders above $100). 
Example :Input: order: Pizza($20), Burger ($10)....>Output:Total after tax = $32.40 

Stack Definition:
A Stack is a linear structure that follows the last-in-first-out(LIFO) principle, meaning the last element added to the stack will be the first one to be removed. A stack can be thought of as a vertical pile of plates, where plates are added and removed from the top of the pile.

Element of a stack:
1. Top: The top element of the stack is the most recently added element, and it is the first one to be removed.
2. Bottom:The bottom element of the stack is the first element added to the stack, and it is the last one to be remove.
3. Elements:The element of a stack are the individual itmes stored in the stack. They can be of any data type, such as integers, strings, or objects.
4. Size: The size of a stack refers to the number of element currently stored in the stack.

Stac Operations:
1. Push: Adding an element to the top of the stack.
2. Pop: Removing the top element from the stack.
3. Peek: Viewing the top elemnt without removing it.
4. IsEmpty: Checking if the stack is empty.
5. Size: Gettimg the number of elements in the stack.

#direct list implementation 
stack=[]
stack.append(1)
stack.append(2)
stack.append(3)
print(stack)

Output:
[1, 2, 3]

#direct list implementation 
stack=[]
stack.append(1)
stack.append(2)
stack.append(3)
print(stack)
popped =stack.pop()
print(popped)
print(stack)
top=stack[-1]
print(top)

Output:
[1, 2, 3]
3
[1, 2]
2

#direct list implementation 
stack=[]
stack.append(1)
stack.append(2)
stack.append(3)
print(stack)
popped =stack.pop()
print(popped)
print(stack)
top=stack[-1]
print(top)
is_empty = len(stack) == 0
print(is_empty)
size = len(stack)
print(size)
stack = []
stack.extend([1,2,3])
print(stack)
stack.insert(0,0)
print(stack)
stack.remove(2)
print(stack)

Output:
[1, 2, 3]
3
[1, 2]
2
False
2
[1, 2, 3]
[0, 1, 2, 3][1, 2, 3]
3
[1, 2]
2
False
2
[1, 2, 3]
[0, 1, 2, 3]
[0, 1, 3]

program:

class stack:
    def __init__(self):
        self.items = []
    def push (self,item):
        self.items.append(item)
    def pop(self):
        if not self.is_empty():
            return self.items.pop()
        else:
            raise IndexError("stack is empty")
    def peek(self):
        if not self.is_empty():
            return self.items[-1]
        else:
            raise IndexError("stack is empty")
    def is_empty(self):
        return len(self, items) == 0
    def size(self):
        return len(self.items)
    def __str__(self):
        return str(self.items)
stack=stack()  
stack.push(1)
stack.push(2)
stack.push(3)
print(stack)
print(stack.peek())
# pop elements from the stack
print(stack.pop())
print(stack.pop())
print(stack.pop())
print(stack.is_empty())
try:
    stack.pop()
except IndexError as e:
    print(e)
  
Queue Definition: 
A queue is a linear data structure that follows the First-In-First-out(FIFO) principle, meaning the first element added to the queue will be the first one to be removed. A queue can be thought of as a line of people waiting for a service, where the person who arrives first is served first.

Element of a queue:
1. Front: The front element of the queue is the first element added to the queue and is the first one to be removed.
2.Rear: The rear element of the queue is the last element added to the queue and is the last element to be removed from the queue.
3. Elements: The elements of a queue are the individual items stored in the queue. They can be of any data type, such as integers, strings or objects.
4. Size: The size of a queue refers to the number of elements currently stored in the queue.

Queue operations:
1. Enqueue: Adding an element to the rear of the queue.
2. Dequeue: Removing the front element from the queue.
3. Peek: Viewing the front element without removing it.
4. IsEmpty: Checking if the queue is empty.
5. Size: Getting the number  of elements in the queue.

Implementation of queue:
Here are the example of implementing a queue using a list, an object and a queue:

Queue using list
queue=[]
queue.append(1)
queue.append(2)
queue.append(3)
print(queue.pop(0))
print(queue.pop(0))
print(queue)
if not queue:
    print("Queue is empty")
else:
      print("Queue is not empty")

# remove duplicate from string 

Genrator:
>To return the value without using return function.
>a function or expression that will process a given iterable one object at a time on demand.

Example:
def hh()
n=1
yield n
n+=11
yield n
h=hh()
print(next(h))
print(next(h))

Linked List:
A linked list is a dynamic data structure consisting of nodes, where each node contains data and a references (or "link") to the next node in the sequences.

Data|Next.............>Data next.........>Data next.........>Null
  |
  |
head

Elements of Linked List:
1.Node: The basic building blocks of a linked list.
     -data: The value stored in the node.
     -next: A references to the next node in the sequences.
2. Head: The first node in the Linked list.
3. Tail: The last node in the linked list.

Operations of linked list:
1. insert_at_head(data): Adds a new node with data at the beginning of the list.
2. insert_at_tail(data): Adds a new node with data at the end of the list.
3. insert_after(node,data): insert a new node with data after the specified node.

Deletion operators:
1. delete_at_head(): Remove the first node from the list.
2. delete_at_tail(): Removes the last node from the list.
3. delete(node): Removes the specified node from the list.

Traversal operators:
1. traverse(): Iterates through the node in the list, returning their data.

Types of Linked List:
1.Singly Linked List 
2.Doubly Linked List
3.Circular Linked List

Cirucular Linked List
Applications:
1.Music or media player
2.Memory allocation
3.Navigation systems

Doubly Linked list:
A doubly linked list is a data structure in which each node as two pointers:
-next:Points to the next node in the sequence.
-prev:Points to the previous node in the sequence.

Application of Doubly Linked List
1. Redo and undo functionality.
2. Used in networking
3.used in graph algorithm.

Important Sorting Algorithm:
>Selection sort
>Bubble sort
>Insertion sort
>Quick sort
>Merge sort

Bubble sort program:
def bubble_sort(arr):
    for n in range(len(arr)):
        for i in range(len(arr)- n - 1):
            if arr[i]>arr[i+1]:
                temp = arr[i]
                arr[i] = arr[i+1]
                arr[i+1] = temp
arr=[39, 12, 18, 85, 72, 10, 2, 18]
print("Unsorted list is:")
print(arr)
bubble_sort(arr)
print("sorted list is:")
print(arr)

Output:
Unsorted list is:
[39, 12, 18, 85, 72, 10, 2, 18]
sorted list is:
[2, 10, 12, 18, 18, 39, 72, 85]

Merge sort:
.The merge sort algorithm is a divide-and-conquer algorithm that sorts an array by first breaking it down into smaller arrays, and then building the array back together the correct way so that it is sorted.
.Divide: The algorithm starts with breaking up the array into smaller and smaller pieces until one such sub-array only consists of one element.
.Conquer: Thwe algorithm merges the small pieces 

def mergeSort(arr):
    if len(arr) <=1:
        return arr
    mid = len(arr) //2
    leftHalf = arr[:mid]
    rightHalf = arr[mid:]
    sortedleft = mergeSort(leftHalf)
    sortedright = mergeSort(rightHalf)
    return merge(sortedleft, sortedright)
def merge(left, right):
    result = []
    i = j =0
    while i<len(left) and j<len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i+=1
        else:
            result.append(right[j])
            j+=1
    result.extend(left[i:])
    result.extend(right[j:])
    print(i,j)
    return result
unsortedArr = [3,7,6,-10,15,23,5,55,-13]
sortedArr = mergeSort(unsortedArr)
print("Sorted array:",sortedArr)
    
Output:
y
1 0
0 1
1 2
1 0
0 1
1 1
2 2
4 2
Sorted array: [-13, -10, 3, 5, 6, 7, 15, 23, 55]


step2: The splitting s

Tree:
A Non-Linear Data Structure 
.A tree is an abstract model of a hierarchical structure that consist of nodes with a parent-child relationship.
.Tree is a sequences of nodes.
.There is a starting node known as root node.         
.Every node other than the root has a parent node.
.Nodes may have any number of children.              

Some Key Terms:
>Root: Node at th top of the tree is called root.
>Parent: Any node except root node has one edge upward to a node called parent.
>Child: Node below a given node connected by its edge downward is called its child node.
>Sibling: Child of same node are called siblings.
>Leaf: Node which does not have any child node is called leaf node.
>Sub tree: Sub tree represents descendants of a node.
>Levels: Level of a node represents the genration of a node, If root node is at level 0, then its next child node is at level1, its grandchild is at level 2 and so on.
>Keys: Key represents a value of a node based on which a search operations is to be carried out for a node.

Characteristics of trees:
.Non-linear data structure.
.Combines advantages of an ordered array.
.Searching as fast as in ordered array.
.Insertion and deletion as fast as in linked list.
.Simple and fast.  

Introduction To Binary Trees
.A BINARY TREE, is a tree in which no node can have more than two children.

Types:
>Full Binary Tree
>Perfect Binart Tree
>Complete Binary Tree

Full Binary Tree
.A Binary tree in which each node has exactly zero or two children is called a full binary tree>
.Every node other than leaf nodes has 2 child nodes.

Perfect Binary Tree:
.All nodes have two children and all leaves are at the same level.

Complete Binary Tree:
.A binary tree that is completely filled with the exception of the lowest level that is filled from left to right.

Tree traversal:
.Traversal is a process to visit all the nodes of a tree and may print their valus too.
.All nodes are connected via edges (links) we always start from the root (head) node.

Tree Traversal:
>.In-order
  .Pre-order
  .Post-order
>Level-order

In-order Traversal:
>Left Root Right

class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
def in_order_traversal(root):
    if root:
        in_order_traversal(root.left)
        print(root.value, end=' ')
        in_order_traversal(root.right)
def build_tree():
    root = Node(1)          
    root.left = Node(2)     
    root.right = Node(3)     
    root.left.left = Node(4)  
    root.left.left.left = Node(5) 
    root.left.left.right = Node(6) 
    root.right.left = Node(7)  
    root.right.right = Node(8)  
    return root
if __name__ == "__main__":
    root = build_tree()
    print("In-order Traversal:")
    in_order_traversal(root)

Output:
In-order Traversal:
5 4 6 2 1 7 3 8 

Pre-order Traversal:
>Root Left Right
Post-order traversal
>Left Right Root

Level-order
Level wise from right to left.

Basic Level Program:
1. Write a python program to count the number of even and odd number in a series of numbers.

def count_even_odd(numbers):
    even_count = 0
    odd_count = 0

    for num in numbers:
        if num%2 == 0:
            even_count+=1
        else:
            odd_count += 1
    
    return even_count, odd_count
numbers = list(map(int, input("Enter a series of numbers seprated by spaces: ").split()))
even_count, odd_count = count_even_odd(numbers)
print(f"Even numbers:{even_count}")
print(f"Odd numbers:{odd_count}")                   

Output:
Enter a series of numbers seprated by spaces: 1 2 3 4 5 6 7 8 9
Even numbers:4
Odd numbers:5


2. Write a python program to create the multiplication table (from 1 to 10) of a number.

number = 1250
for i in range(1, 11):
    print(f"{number} x {i} = {number * i}") 

Output:
1250 x 1 = 1250
1250 x 2 = 2500
1250 x 3 = 3750
1250 x 4 = 5000
1250 x 5 = 6250
1250 x 6 = 7500
1250 x 7 = 8750
1250 x 8 = 10000
1250 x 9 = 11250
1250 x 10 = 12500

3. Create a function named remove_sql_specialists(people_list).
Given a list of tuple, it removes people whose job titles contain the word "SQL" from the list.
You can use the in operator to check if a given job title contains the word "SQL".
Use the  following data containing employee names, job titles, and salaries:

new_hires = [('Mark adams', 'SQL Analyst',4000),
('Leslie Burton', 'HR Specialists', 2300),
('Dorothy Castillo', 'UX Designer', 3100)]

 def remove_sql_specialists(people_list):
    return [person for person in people_list if 'SQL' not in person[1]]
new_hires = [('Mark Adams', 'SQL Analyst', 4000),
    ('Leslie Burton', 'HR Specialist', 2300),
    ('Dorothy Castillo', 'UX Designer', 3100)]
filtered_hires = remove_sql_specialists(new_hires)
print(filtered_hires)

Output:
[('Leslie Burton', 'HR Specialist', 2300), ('Dorothy Castillo', 'UX Designer', 3100)]

Binary Search Tree:
*A Binary search tree is a data structure used in computer science for organizing and storing data in a sorted manner.
*Each node in a Binary Search Tree has at most two children, a left child and a right child, with the left child containing values less than the parent node and the right child containing values greater than the parent node.
*This hierarchical structure allows for efficient searching, insertion, and deletion operation on the data stored in the tree.

Application:
>Directory srtucture of a file store.
>Structure of an airthmatic expression.
>Used in almost every 3D video game to determine what object need to be rendered.
>Used in almost every high-bandwidth route for storing router-tables.
>Used in compression algorithm, such as those used by the .jpeg and .mp3 file-formats.

Expression Tree:
